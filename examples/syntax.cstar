//Auto importing with involved. this means all standard libraries which needed by this unit to be imported, will be imported by automatically
package involved {
    'ML',
    'X',
    'Y', 
}

// also particularly we can import a package or even only a function from it as well
package {
    "std.math"
    "std.math.cos"
}

// Linkage and storage syntax in C*
//those are identical since if there is no return type operator exist on the function, compiler treats like its type none
import func(int8 x,bool y) as callMe :: none; 
import func(int8 x,bool y) as callMe;
import {
    func(int x8,bool y) as callMe;
    func(int32 x,int64 y) as dontCallMe;
}
import glClearColor as func(float r,float g,float b,float a) :: none from "opengl32.lib";
import from "myLibrary.lib" {
    printf as func(char*) :: none;
    callMe as func() :: none;
}

//float is automatically replaced by float64 or float32 which depends on the system architecture flag
export area<Circle> as func(float x,float y) :: float32;
export sin as func(float64 x) :: float64 from "std.math";
export from "std.math" {
    abs as func(int32 x) :: int32;
    fabs as func(float32 x) :: float32;
}
if(isType(toke
//This is the way of using features of Metaprogramming..
attribute as Area<T> {
    area -> T match {
        'Triangle':  self.$0 * self.$1 / 2,
        'Square': self.$0 * self.$1,
        _: ''
    }
}

attribute as Area<Circle> {
    area -> 2 * math.PI * self.$0;
}

//meta types for reflectivity
attribute as IsRef<T> {
    is_ref -> meta_ref(self.$0);
}


//Classic macro needs
macro as print(str) {
    std.out(str)
}

macro as triangle_area(x,y) {
    x * y / 2;
}

macro as unique_vec(expr){
    vector^ temp_vec = instanceof vector();
    loop(i in expr){
        temp_vec.push(i)
    }
    ret temp_vec;
}

prototype as Shape from Area { 
    float32 x;
    float32 y;
    float32 _z; // private

    constructor() { // this is going to be called by instanceof operator

    } 


    //if there is no parameters, we can write the function in three different ways
    func() as area :: float32 {}
    func as area :: float32 {}
    area :: float32 {}
    // even if its return type is none we can just write like this but this style 
    // is not valid when we use it as local function inside of another function
    area {}

    func(int x,int y) as area<Square> :: float32;
    func(float32 x,float32 y) as area<Triangle> :: float32;

    func(x bool,bool y) as cast_is_not_possible {
        // it's legal and not breaking PTD (primitive type domination) rule
        int32 a = x; // but still illegal implicit casting since 'x bool' semantically dictate that you can't cast this parameter in this whole scope
        int32 b = y; // but this is legal since there is no restriction semantically since 'bool y'.
    }
}

prototype as Triangle(Shape) {

}

//This means pass by address by ref but it can't be changed
func([int32&] by_ref) as example :: none {

}

//This means ref it can be changed
func(int32& by_ref) as example1 :: none {

}

//This means pass by address that unique pointer but it can't be changed
//and it has an unique ownership which is not able to be shared with
//another pointer and it can be moved but not allowed by [^]
func([int32^] ptr) as example2 :: any {
    //this is not possible because ^ pointers are can't be shared
    //int32^ movedHere = ptr;
}

//This means pass by address that unique pointer it 
//has an unique ownership which is also not able to be shared with
//another pointer and it can be moved since ^
func(int32^ ptr) as example3 :: any {
    //moved here not shared ptr!!
    int32^ movedHere = ptr;
    ptr = instance Triangle();
} 


//This means pass by address that shareable pointer but it can't be changed
//and it can have many ownerships which is able to be shared with
//another pointer and it can be moved but not allowed by [*]
func([int32*] ptr) as example4 :: any {
    int32* sharedHere = ptr;

    //not possible
    //sharedHere = instanceof Triangle(); 
}

//This means pass by address that shareable pointer but it can't be changed
//and it can have many ownerships which is able to be shared with
//another pointer and it can be moved since *
//when shareable pointer moved, previous pointer will be nil.. and counter does not increase
func(int32* ptr) as example5 :: any {
    int32* sharedHere = ptr;
    sharedHere = instanceof Triangle(); 
}


func() main :: int32 {
    int32 x = 30;
    int32* p = ref x;

    //unsafe cast is trying to save ur ass from trouble with type conversions like uint32 -> int32
    uint32 a = 1233;
    int32 p = a; // this will be a stupid assignment here
    int32 l = unsafe_cast<int32>(a); // it tries to understand what to do and helps implicitly if it can (2's complement)
    float32 f = 12.3453;
    int32 r = f; //implicitly casting
    Shape^ shape = instanceof Triangle();
    Triangle^ triangle = cast<Triangle^>(shape); 

    if(x == 10) {

    } elif (x > 10) {

    } else {

    }

    loop(true) {

    }

    int32 arr[] = {0,1,2,3}
    loop(v in arr) {
        print(v)
    } 

    //by index
    loop(i,v in arr){
        print(i,v)
    }

    //by index and address p -> pointer -> address
    loop(i,v,p in arr){
        print(i,v,p)
    }

    int32 k = 1;
    option(k) {
        0: {

        },
        1: {

        },
        2: {

        },
        3: {

        },
        _: {

        }
    }

    ret 0;
}
