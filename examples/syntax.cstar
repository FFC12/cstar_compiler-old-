//Auto importing with involved. this means all standard libraries which needed by this unit to be imported, will be imported by automatically
package involved {
    'ML',
    'X', //sin -> X.sin
    'Y', //sin -> Y.sin
}

// also particularly we can import a package or even only a function from it as well
package {
    "std:math"
    "std:math:cos"
}

// Linkage and storage syntax in C*
//those are identical since if there is no return type operator exist on the function, compiler treats like 
//its type is none
import callMe(int8 x,bool y) :: none; 
import callMe(int8 x,bool y);
import {
    callMe(int x8,bool y);
    dontCallMe(int32 x,int64 y);
}
import glClearColor(float r,float g,float b,float a) :: none from "opengl32.lib";
import from "myLibrary.lib" {
    printf(char*) :: none;
    callMe() :: none;
}

//float is automatically replaced by float64 or float32 which depends on the system architecture flag
export area<Circle>(float x,float y) :: float32;
export sin(float64 x) :: float64 from "std:math";
export from "std:math" {
    abs(int32 x) :: int32;
    fabs(float32 x) :: float32;
}

//This is the way of using features of Metaprogramming..
attribute Area<T> {
    area($0,$1) -> T match {
        'Triangle': $0 * $1 / 2,
        'Square': $0 * $1,
        _: cterror("no this is not valid type")
    }
}

attribute Area<Circle> {
    area($0) -> 2 * math.PI * $0;
}

//meta types for reflectivity
attribute IsRef<T> {
    is_ref($0) -> std.meta_ref($0);
}


//Classic macro needs
macro print(str) {
    std.out(str)
}

macro triangle_area(x,y) {
    x * y / 2;
}

macro unique_vec(expr){
    vector^ temp_vec = vector();
    loop(i in expr){
        temp_vec.push(i)
    }
    ret temp_vec;
}

prototype Shape<T> from Area<T> { 
    float32 x;
    float32 y;
    float32 _z; // private
 
    constructor() { 
    } 

    //if there is no parameters, we can write the function in three different ways
    area() :: float32 {}
    area() :: float32 {}
    area() {} 

    area<Square>(int x,int y) :: float32;
    area<Triangle>(float32 x,float32 y) :: float32;

    cast_is_not_possible(x bool,bool y) :: none {
        // it's legal and not breaking PTD (primitive type domination) rule
        int32 a = x; // but still illegal implicit casting since 'x bool' semantically dictate that you can't cast this parameter in this whole scope
        int32 b = y; // but this is legal since there is no restriction semantically since 'bool y'.
    }
}

prototype Triangle(Shape) {

}


a_func(int32, int); 


//This means pass by address by ref but it can't be changed
example(int32& by_ref) :: none {

}

//This means ref it can be changed
example1(int32& by_ref) :: none {

}

//This means pass by address that unique pointer but it can't be changed
//and it has an unique ownership which is not able to be shared with
//another pointer and it can be moved but not allowed by [^]
example2(int32^ ptr) :: any {
    //this is not possible because ^ pointers are can't be shared
    //int32^ movedHere = ptr;
}

//This means pass by address that unique pointer it 
//has an unique ownership which is also not able to be shared with
//another pointer and it can be moved since ^
example3(int32^ ptr) :: any {
    //moved here not shared ptr!!
    int32^ movedHere = ptr;
    ptr = Triangle();
} 


//This means pass by address that shareable pointer but it can't be changed
//and it can have many ownerships which is able to be shared with
//another pointer and it can be moved but not allowed by [*]
example4([int32*] ptr) :: any {
    int32* sharedHere = ptr;

    //not possible
    //sharedHere = Triangle(); 
}

//This means pass by address that shareable pointer but it can't be changed
//and it can have many ownerships which is able to be shared with
//another pointer and it can be moved since *
//when shareable pointer moved, previous pointer will be nil.. and counter does not increase
example5(int32* ptr) :: any {
    int32* sharedHere = ptr;
    sharedHere = Triangle(); 
}


 main() :: int32 {
    int32 x = 30;
    int32* p = ref x;
    x = deref p;

    //unsafe cast is trying to save ur ass from trouble with type conversions like uint32 -> int32
    uint32 a = 1233;
    int32 p = a; // this will be a stupid assignment here
    int32 l = unsafe_cast<int32>(a); // it tries to understand what to do and helps implicitly if it can (2's complement)
    float32 f = 12.3453;
    int32 r = f; //implicitly casting
    Shape^ shape = Triangle(); 
    Triangle^ triangle = cast<Triangle^>(shape);
    
    const Shape^ ptr = Triangle(); // the address is not constant and the value it holds cannot be changed.
    constptr Shape^ ptr = Triangle(); // the address is constant and but the value it holds can be changed.
    readonly Shape^ ptr = Triangle(); // the address and the value are constant and this is readonly.

    //for stack-kind variables.
    const Shape shape;
    //constptr Shape shape; this is wrong since Shape is not a pointer-type variable
    //readonly Shape shape; this is wrong since Shape is not a pointer-type variable

    if(x == 10) {

    } elif (x > 10) {

    } else {

    }

    loop(true) {

    }

    int32 arr[] = {0,1,2,3}
    loop(v in arr) {
        print(v)
    } 

    //by index
    loop(i,v in arr){
        print(i,v)
    }

    //by index and address p -> pointer -> address
    loop(i,v,p in arr){
        print(i,v,p)
    }

    int32 k = 1;
    option(k) {
        0: {
        
        },
        1: {

        },
        2: {

        },
        3: {

        },
        _: {

        }
    }

    ret 0;
}
