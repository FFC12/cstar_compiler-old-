int r = sizeof(p) + cast(x + y) / 2;
int k = sizeof(int) + 10 * 5 + unsafe_cast<int32*>(10 + 20 * 25 / 3) * sizeof(int) + cast<int64>(10) + 20 * 20; // + sizeof(10);
int z = unsafe_cast<int32^>(cast<int32**>(30 + 2 / 2) % 2) * 3 * 3 * 3 + 4;
int v = sizeof(float) / 2;

/*
int i = 20 + *k + ***p;
int ^^^^^^^^k, ***l = &x;
int***** l = &k;

int x, s = 20, p = 30;
float k= 30;
int32 z = 30;
int t = 25000;
intt k = 200; //cannot catch in the pre-parsing. it will be catched on the type checking phase...
int l = 123;

int32 x = 30;
int* k = &x;
int***** l = &k;
int^^^^^ r = &x;
int32* p = ref x;
x = deref p;

//unsafe cast is trying to save ur ass from trouble with type conversions like uint32 -> int32
uint32 a = 1233;
int32 p = a; // this will be a stupid assignment here
int32 l = unsafe_cast<int32>(a); // it tries to understand what to do and helps implicitly if it can (2's complement)
float32 f = 12.3453;
int32 r = f; //implicitly casting
Shape^ shape = Triangle(); 
Triangle^ triangle = cast<Triangle^>(shape);

const Shape^ ptr = Triangle(); // the address is not constant and the value it holds cannot be changed.
constptr Shape^ ptr = Triangle(); // the address is constant and but the value it holds can be changed.
readonly Shape^ ptr = Triangle(); // the address and the value are constant and this is readonly.

//for stack-kind variables.
const Shape shape; 
int p = &i; 

int s[2] = {0,1}, k[3] = {0,1,2}, a[2][3] = {{0,1,2},{3,4,5}}; 

*/ 